=============================================

Seminar Modern C++

Guten Morgen

Peter Loos

=============================================

Github

github.com/pelocpp

https://github.com/pelocpp

35+ Jahre

Entwicklung // Schulung // Training

C/C++, Java,  C#,  Mobile Progr. (Flutter)

Back-to-the-Roots

==============================================

Todo:

emplace 

noexcept

std::swap - Idiom

RAII

==============================================


C++ 11

C++ 17

==============================================

auto:

A) Variablen vereinbaren
B) Rückgabetyp von Funktionen
C) Als Datentyp für Parameter ( templates )

// ==================================================

Idiome:

multi

Objekt-orientiert
GP // generische Progr.
funktional

Bjarne Stroustrup

Alexander Alexandrowitsch Stepanow // Gen. Progr.

Bjarne Stroustrup ===> Bibliothek: C++ // template STL Standard TEMPLATE Libr.

=====================================

auto

Vorsicht / Achtung:

====================================

std::vector <int> numbers;  // 10000

Daten:

== Stack
== Heap  // <====================
== Globales Datensegment

// zu klein, umkopieren ...

std::vector:   per Def:  continuous // dicht aneinanderliegend

std::deque:  NICHT dicht ...

IDENTISCH;

char data [100000];


std::vector<char> data;

data[index] = ???;   // Anfangsadresse + offset

resize ();

======================================

C:

C versus C++:

a) Robustheit:  std::vector

b) Performance: 

STL - Algorithmen




std::vector<char> data;   // LEER

push_back / 1 Element

std::vector<char> data (10);

Anwender:  Leer

Um wieviel:  neue Länge = alte Länge * 1.5;

Beispiel: 100 // 150 // 275


======================================

Lambda:

== Sprachliches Mittel

== STL - Algorithmen 

== Optimierungspotential:  Inline 

==> NOT : Gebrauchsanweisung

=> Whyyyyyy // Howwww

Modern C++:

Viele neue Sachen  .... vieles wird auf Vorhandenes umgesetzt.

Aufrufbares Objekt

Funktor

operator():  Wozu ...

Das ist eine Methode ... OHNE Namen.

=============================

OHNE Ref.

            int value = n1;
00007FF6E0A48E3A  mov         eax,dword ptr [n1]  
00007FF6E0A48E40  mov         dword ptr [value],eax  

Mit Ref:  == eine Adresse

            int value = n1;
00007FF70E6B8E3B  mov         rax,qword ptr [n1]  
00007FF70E6B8E42  mov         eax,dword ptr [rax]  
00007FF70E6B8E44  mov         dword ptr [value],eax  

=========================================

Lambda Funktion

Lambda Objekt

Jedes Lambda ist vom Typ einer (lokalen) Klasse.

==> Was haben Objekte: Methoden und Instanzvariablen.

=========================================

Cpp Insights

=========================================

Move Semantik
-------------

a) Neue Referenz: RValue Referenz

Ab C++ 11: Einen zweiten Referenz-Typus:   RValue

Einen für anonyme Objekte.    // Whyyyyyyyyyyyyyyyyyyyyyyyy

b) Move Semantik

Referenz:    Ist ein Alias-Name eines vorhandenen Objekts.

================================================

Man möchte unnötige Kopien vermeiden.

================================================

... E60    ... temp. Objekt am Stack ... wird freigegeben
... ED0    ... im Vektor

================================================

Rule-of-Three:   Um double - free / delete zu vermeiden !!!

Um eine echte Kopie anzulegen.

... 1024


... 1C0

==============================================

... 310

=============================================

new  ===> In Modern C++ sollte man new nicht verwenden.

Sondern:  Smart Pointer

=============================================

In Modern C++ sollte man new nicht verwenden.


Wording:  Classic Pointer  // Raw Pointer.

Whyyyyyyyyyyyyyyyy:  pro new erwarten wir ein delete.

Suchen nach fehlenden sind:  

Death March von Ed Yourdon.

Lösung des fehlenden deletes:

Idee:

i) OO:  Klassen und Objekten

ii) Konstruktoren
    Destruktoren

iii) Beobachtung: Wann wird ein Destruktor aufgerufen?

    Am Ende des Scopes 
    // bei Objekten am Stack.

    Deterministisch.

iv) Ein Pointer von new: 

    Hüllenobjekt / Wrapper versteckt:

    ==> Konstruktor
    ==> Destruktor:   delete

a) auto_ptr

b) std::unique_ptr
   std::shared_ptr  // std::weak_ptr

================================================

Legacy: Vorsicht :)

Neue Module ....

================================================

i)    std::unique_ptr

Hat im Programm zu EINEM Zeitpunkt genau
EINEN Besitzer.

ii)   std::shared_ptr  // std::weak_ptr

Kann im Programm zu EINEM Zeitpunkt mehrere
Besitzer haben.

================================================

std::unique_ptr

============================================

std::unique_ptr:

geht mit Array:

std::unique_ptr<int[]> ptr{ new int[100] };

int* begin = ptr.get();

begin[15]


VOOOOOOOOOORSICHT:

Da gibt es eigentlich fast keinen Grund dafür,
weil die vector auch tut !!!!!!!!!!!!!!!!!

Der einzige Grund:   

Ein Block an Speicher, der NICHT initialisiert ist:

new ElemTyp[100]

std::malloc // std::free

Uninitialized memory algorithms
uninitialized_copy
uninitialized_fill
uninitialized_move
(C++17)
uninitialized_copy_n
(C++11)
uninitialized_fill_n
uninitialized_move_n
(C++17)
construct_at
(C++20)
uninitialized_default_construct
(C++17)
uninitialized_value_construct
(C++17)
destroy
(C++17)
uninitialized_default_construct_n
(C++17)
uninitialized_value_construct_n
(C++17)
destroy_n
(C++17)
destroy_at
(C++17)

============================================


Smart Pointer:

new // delete ===> Smart Pointer  ==>  Rule-of-Zero.

STL Container // Algorithmen
Smart Pointer (kein new/delete)  ==> Move Semantik.

============================================

Pufferüberlauf:

NICHT:  C-Style Array:

int numers[100];
......
int index = 101;
numbers[index] = 999;

Unterstützung:

Go for std::vector

Go for std::array:    STL Klasse

=================================================

Wehrmutstropfen

Der std::shared_ptr funktioniert nicht immer :-((((((((

Nicht immer wird delete aufgerufen, wenn es der Fall sein sollte.

Wenn der Referenzzähler auf 0 geht, wird delete aufgerufen !!! Stimmt!

Aber: Der Referenzzähler geht nicht immer auf 0 ??????? !!!!!!

Hat was mit Zirkulärem zu tun ;)

i)   std::weak_ptr

ii)  Whyyyyyyyyyyyyyyyyyyyyyyy


